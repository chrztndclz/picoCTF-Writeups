
## heap 0

**Platform:** picoCTF 2024

**Author:**  ABRXS, PR1OR1TYQ

**Category:**  Binary Exploitation

**Difficulty:** Easy

Tags:
#picoCTF_2024 
#Binary_Exploitation
#Easy 

---

## Description

Are overflows just a stack concern? 

Download the binary here. 
Download the source here.

Additional details will be available after launching your challenge instance.

Connect with the challenge instance here: 
nc tethys.picoctf.net 64339

---

## Hints
- What part of the heap do you have control over and how far is it from the safe_var?

---

## Analysis


This challenge demonstrates that buffer overflows can also occur on the heap, not just on the stack. The program allocates two small memory chunks using malloc:

input_data (5 bytes)

safe_var (5 bytes)

You can write into input_data using scanf("%s"), which is unsafe because it does not check the size of the buffer. This means any input longer than 5 bytes will overflow and start overwriting the next area in heap memory. In this challenge, safe_var happens to be about 32 bytes after input_data, so a short overflow does nothing. But a longer input (40–50 characters) will reach safe_var and change its contents.

The flag is revealed if safe_var is not equal to "bico". Once your overflow corrupts safe_var, the program’s check fails and the flag is printed.

---

## Methodology
**Step 1:** Connect to the service

nc tethys.picoctf.net 58286
The program immediately prints the two heap addresses, letting us measure the distance between them.

**Step 2:** Overflow input_data

Choose option 2 and enter an input longer than 32 bytes:

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

This overflows input_data and reaches safe_var.

Step 3: Check if safe_var != "bico" since base on the source code is this satisfied you'll get the flag 

Choose option 1:


<img width="657" height="182" alt="image" src="https://github.com/user-attachments/assets/1ae9ba4c-4206-497d-bd07-e53dd1840d2e" />


**Step 4:** check the safe_var if modified 

Choose option 3:


<img width="489" height="90" alt="image" src="https://github.com/user-attachments/assets/51e63cec-4ab8-4eb6-978c-1f45bbb8c435" />


**Step 5:** Retrieve the flag

Choose option 4.
Since safe_var != "bico", the program print

YOU WIN


---

## Flag

picoCTF{my_first_heap_overflow_4fa6dd49}
picoCTF{my---------d49}

---

## Reflection

This challenge clearly shows how dangerous unchecked input can be, especially when using functions like scanf("%s") that do not enforce size limits. It highlights that buffer overflows are not limited to stack memory—the heap is equally vulnerable when programs allocate small buffers and trust user input. Understanding how heap memory is laid out and how adjacent chunks can be corrupted helps build a strong foundation for more advanced heap exploitation techniques.

---

## Tools

nc (Netcat) – Used to connect to the remote challenge instance.

Source Code Review – Helps identify buffer sizes and vulnerable functions.

Manual Memory Offset Calculation – Used to determine how far one heap chunk is from another.

----

## References

[Buffer Overflow Basics](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)

[scanf("%s") vulnerability explanation](https://stackoverflow.com/questions/1628649/why-is-scanf-so-dangerous)

[Heap memory & malloc layout](https://developer.mozilla.org/en-US/docs/Web/Memory_Management)
