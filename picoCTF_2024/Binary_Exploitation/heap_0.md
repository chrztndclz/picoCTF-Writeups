
## heap 0

**Platform:** picoCTF 2024

**Author:**  ABRXS, PR1OR1TYQ

**Category:**  Binary Exploitation

**Difficulty:** Easy

Tags:
#picoCTF_2024 
#Binary_Exploitation
#Easy 

---

## Description

Are overflows just a stack concern? 

Download the binary here. 
Download the source here.

Additional details will be available after launching your challenge instance.

Connect with the challenge instance here: 
nc tethys.picoctf.net 64339

---

## Hints
- What part of the heap do you have control over and how far is it from the safe_var?

---

## Analysis


This challenge is about understanding how memory on the heap can be overwritten if a program doesn’t properly limit user input. The program creates two pieces of memory on the heap: one called input_data and another called safe_var. input_data is where the user is allowed to write, and safe_var is a protected value the program thinks you cannot change. The key vulnerability happens because input_data is only 5 bytes long, but the program uses scanf("%s") to read user input into it. This function does not stop at 5 bytes—it keeps writing until it encounters whitespace. Since the heap stores blocks one after another, writing more than 5 bytes into input_data causes the extra characters to spill over into the next memory area. In this challenge, that next area is safe_var.

When you first overflowed input_data with just a few extra characters, nothing happened because the two variables were actually around 32 bytes apart in memory. That meant your input wasn’t long enough to reach and overwrite safe_var. Once you used a much longer input (around 40–50 characters), the overflow finally crossed the gap and changed the value inside safe_var. The program checks whether safe_var still equals "bico" when you select “Print Flag.” Since the overflow changed it, the check fails, and the program prints the flag. The whole challenge is simply about overflowing a heap buffer far enough to modify a value the program mistakenly thinks is protected.

---

## Methodology
**Step 1:** Connect to the service

nc tethys.picoctf.net 58286
The program immediately prints the two heap addresses, letting us measure the distance between them.

**Step 2:** Overflow input_data

Choose option 2:

Then enter a payload larger than 32 bytes:

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA


This overwrites safe_var.

Step 3: Check if safe_var != "bico" since base on the source code is this satisfied you'll get the flag 

Choose option 1:


<img width="657" height="182" alt="image" src="https://github.com/user-attachments/assets/1ae9ba4c-4206-497d-bd07-e53dd1840d2e" />


**Step 4:** check the safe_var if modified 

Choose option 3:


<img width="489" height="90" alt="image" src="https://github.com/user-attachments/assets/51e63cec-4ab8-4eb6-978c-1f45bbb8c435" />



**Step 5:** Since you confirmed that you satisfied the need to print the flag. Retrieve the flag. 

Choose option 4:

YOU WIN


---

## Flag

picoCTF{my_first_heap_overflow_4fa6dd49}
picoCTF{my---------d49}

---

## Reflection

This challenge showed how dangerous it is when programs don’t properly limit user input, especially when working with memory. Before this, it’s easy to think buffer overflows only happen on the stack, but this problem proves that the heap can be just as vulnerable. It also teaches that even a small mistake, like using scanf("%s") without a size limit, can allow an attacker to overwrite important data. Seeing how the two variables were close together in memory—and how overflowing one could modify the other—helps build a better understanding of how memory is actually laid out behind the scenes. Overall, this challenge is a great introduction to how memory corruption works and why secure coding practices are so important.

---

## Tools


----

## References
