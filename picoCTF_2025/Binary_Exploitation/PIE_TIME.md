<img width="668" height="120" alt="image" src="https://github.com/user-attachments/assets/922709e5-7806-4fa6-b45e-c3918d809c31" />
## PIE TIME

**Platform:** picoCTF 2025

**Author:** DARKRAICG492

**Category:**  Binary Exploitation

**Difficulty:** Easy

Tags:
#picoCTF_2025 
#Binary_Exploitation 
#Easy 

---

## Description

Can you try to get the flag? Beware we have PIE!

Additional details will be available after launching your challenge instance.

Connect to the program with netcat:

$ nc rescued-float.picoctf.net 59818

The program's source code can be downloaded here. The binary can be downloaded here.

---

## Hints
- Can you figure out what changed between the address you found locally and in the server output?

---

## Analysis

---

## Methodology

**Step 1:** Download the file 

**Step 2:** Make both file executable 

<img width="664" height="195" alt="image" src="https://github.com/user-attachments/assets/d35f8e78-e2bc-4215-a868-a9b31af32d59" />

**Step 3:** Run the Source Code

`cat vuln.c `

```
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void segfault_handler() {
  printf("Segfault Occurred, incorrect address.\n");
  exit(0);
}

int win() {
  FILE *fptr;
  char c;

  printf("You won!\n");
  // Open file
  fptr = fopen("flag.txt", "r");
  if (fptr == NULL)
  {
      printf("Cannot open file.\n");
      exit(0);
  }

  // Read contents from file
  c = fgetc(fptr);
  while (c != EOF)
  {
      printf ("%c", c);
      c = fgetc(fptr);
  }

  printf("\n");
  fclose(fptr);
}

int main() {
  signal(SIGSEGV, segfault_handler);
  setvbuf(stdout, NULL, _IONBF, 0); // _IONBF = Unbuffered

  printf("Address of main: %p\n", &main);

  unsigned long val;
  printf("Enter the address to jump to, ex => 0x12345: ");
  scanf("%lx", &val);
  printf("Your input: %lx\n", val);

  void (*foo)(void) = (void (*)())val;
  foo();
}   
```

**Step 4:** Run the Binary

```
Address of main: 0x55c7305e433d
Enter the address to jump to, ex => 0x12345:

```

**Step 5:** Get Symbol Offsets with objdump
We must extract the relative offsets.

`objdump -d vuln | grep main`

`objdump -d vuln | grep win`


<img width="858" height="253" alt="image" src="https://github.com/user-attachments/assets/682be688-8224-469c-aa5c-57c7ea3542fb" />

000000000000133d <main>:
00000000000012a7 <win>:

Compute offset:

offset = win - main
offset = 0x12a7 - 0x133d
offset = -0x96

Step 6: Run the Program Locally to Verify Leak

Address of main: 0x56384b79b33d

PIE_base = leaked_main - main_offset
         = 0x56384b79b33d - 0x133d
         = 0x56384b79a000


win_runtime = PIE_base + win_offset
            = 0x56384b79a000 + 0x12a7
            = 0x56384b79b2a7

Check:

Local main: 0x56384b79b33d
Local win: 0x56384b79b2a7
Difference: 0x96 â†’ correct.
            
Step 7: Remote Exploit


remote_win = remote_main_leak - 0x96

            
<img width="668" height="120" alt="image" src="https://github.com/user-attachments/assets/7bd0a7e4-5e8d-40f2-8b06-ea9207944baf" />

         

---

## Flag

picoCTF{b4s1c_p051t10n_1nd3p3nd3nc3_fec8b8c5}

---

## Reflection


---

## Tools


----

## References
